// Print matrix in spiral order
class Solution {
public:
    vector<int> spiralOrder(vector<vector<int>>& matrix) {
        vector<int> d;
        int mbegin = 0, mend = matrix.size(), nbegin = 0, nend = matrix[0].size(); // m rows, n cols
        do {
            printBoundary(d, matrix, mbegin, mend, nbegin, nend);
            mbegin++; mend--;
            nbegin++; nend--;
        } while (mbegin < mend && nbegin < nend);
        return d;
    }
    void printBoundary(vector<int>& d, vector<vector<int>>& matrix,
                       int mbegin, int mend,
                       int nbegin, int nend) {
        for (int m = mbegin, n = nbegin; n < nend; n++) { //top row
            d.push_back(matrix[m][n]);
        }
        for (int m = mbegin+1, n = nend-1; m < mend; m++) { //rightmost col
            d.push_back(matrix[m][n]);
        }
        for (int m = mend-1, n = nend-2;
             mbegin != mend-1 && n >= nbegin; n--) { //bottom row (r->l)
            d.push_back(matrix[m][n]);
        }
        for (int m = mend-2, n = nbegin;
             nbegin != nend-1 && m > mbegin; m--) { //first col (b->t)
            d.push_back(matrix[m][n]);
        }
    }
};

//Diagonal traversal (reversing direction) of matrix
class Solution {
public:
    vector<int> findDiagonalOrder(vector<vector<int>>& matrix) {
        vector<int> result;
        if (matrix.empty()) {
            return result;
        }
        int N = matrix.size(), M = matrix[0].size();
        bool up = true;
        for (int i = 0, j = 0; i < N && j < M; ) {
            int r = i, c = j; // gn an index print the diagonal
            while (r >= 0 && r < N && c >= 0 && c < M) {
                result.push_back(matrix[r][c]);
                i = r, j = c;
                if (!up) {
                    r++, c--;
                } else {
                    c++, r--;
                }
            }
            up = !up;
            // matrix[i][j] is the last index pushed
            if (!up) {
                i += (j == M-1) ? 1 : 0;
                j += (j < M-1)  ? 1 : 0;
            } else {
                j += (i == N-1) ? 1 : 0;
                i += (i < N-1)  ? 1 : 0;
            }
            // i,j points to the next head
        }
        return result;
    }
};

//Pascal's triangle
class Solution {
public:
    vector<vector<int>> generate(int numRows) {
        vector<vector<int>> result(numRows, vector<int>());
        for (int i = 0; i < numRows; i++) {
            result[i].push_back(1);
        }
        for (int i = 1; i < numRows; i++) {
            for (int j = 1; j <= i; j++) {
                if (i == j) {
                    result[i].push_back(1);
                    continue;
                }
                result[i].push_back(result[i-1][j-1] + result[i-1][j]);
            }
        }
        return result;
    }
};

// Find pivot index
class Solution {
public:
    int pivotIndex(vector<int>& nums) {
        int total = 0, left = 0;
        for (int num: nums) {
            total += num;
        }
        for (int i = 0; i < nums.size(); i++) {
            if (left == total - nums[i] - left) {
                return i;
            }
            left += nums[i];
        }
        return -1;
    }
};

// Largest # atleast twice of others
class Solution {
public:
    int dominantIndex(vector<int>& nums) {
        if (nums.size() == 1) {
            return 0;
        }
        int max1 = 0, max2 = 1;
        if (nums[max2] > nums[max1])
            swap(max1, max2);
        for (int i = 2; i < nums.size(); i++) {
            if (nums[i] > nums[max1]) {
                max2 = max1;
                max1 = i;
            } else if (nums[i] > nums[max2]) {
                max2 = i;
            }
        }
        if (nums[max2]*2 <= nums[max1]) {
            return max1;
        }
        return -1;
    }
};

// Plus one
class Solution {
public:
    vector<int> plusOne(vector<int>& digits) {
        int c = 1, i = digits.size()-1;
        do {
            int val = digits[i] + c;
            c = (val >= 10) ? 1 : 0;
            digits[i--] = val % 10;
        } while (c == 1 && i >= 0);
        if (c == 1) {
            digits.insert(digits.begin(), 1);
        }
        return digits;
    }
};

// Print matrix in spiral order
class Solution {
public:
    vector<int> spiralOrder(vector<vector<int>>& matrix) {
        vector<int> d;
        int mbegin = 0, mend = matrix.size(), nbegin = 0, nend = matrix[0].size(); // m rows, n cols
        do {
            printBoundary(d, matrix, mbegin, mend, nbegin, nend);
            mbegin++; mend--;
            nbegin++; nend--;
        } while (mbegin < mend && nbegin < nend);
        return d;
    }
    void printBoundary(vector<int>& d, vector<vector<int>>& matrix,
                       int mbegin, int mend,
                       int nbegin, int nend) {
        for (int m = mbegin, n = nbegin; n < nend; n++) { //top row
            d.push_back(matrix[m][n]);
        }
        for (int m = mbegin+1, n = nend-1; m < mend; m++) { //rightmost col
            d.push_back(matrix[m][n]);
        }
        for (int m = mend-1, n = nend-2;
             mbegin != mend-1 && n >= nbegin; n--) { //bottom row (r->l)
            d.push_back(matrix[m][n]);
        }
        for (int m = mend-2, n = nbegin;
             nbegin != nend-1 && m > mbegin; m--) { //first col (b->t)
            d.push_back(matrix[m][n]);
        }
    }
};

//Diagonal traversal (reversing direction) of matrix
class Solution {
public:
    vector<int> findDiagonalOrder(vector<vector<int>>& matrix) {
        vector<int> result;
        if (matrix.empty()) {
            return result;
        }
        int N = matrix.size(), M = matrix[0].size();
        bool up = true;
        for (int i = 0, j = 0; i < N && j < M; ) {
            int r = i, c = j; // gn an index print the diagonal
            while (r >= 0 && r < N && c >= 0 && c < M) {
                result.push_back(matrix[r][c]);
                i = r, j = c;
                if (!up) {
                    r++, c--;
                } else {
                    c++, r--;
                }
            }
            up = !up;
            // matrix[i][j] is the last index pushed
            if (!up) {
                i += (j == M-1) ? 1 : 0;
                j += (j < M-1)  ? 1 : 0;
            } else {
                j += (i == N-1) ? 1 : 0;
                i += (i < N-1)  ? 1 : 0;
            }
            // i,j points to the next head
        }
        return result;
    }
};

//Pascal's triangle
class Solution {
public:
    vector<vector<int>> generate(int numRows) {
        vector<vector<int>> result(numRows, vector<int>());
        for (int i = 0; i < numRows; i++) {
            result[i].push_back(1);
        }
        for (int i = 1; i < numRows; i++) {
            for (int j = 1; j <= i; j++) {
                if (i == j) {
                    result[i].push_back(1);
                    continue;
                }
                result[i].push_back(result[i-1][j-1] + result[i-1][j]);
            }
        }
        return result;
    }
};

// Find pivot index
class Solution {
public:
    int pivotIndex(vector<int>& nums) {
        int total = 0, left = 0;
        for (int num: nums) {
            total += num;
        }
        for (int i = 0; i < nums.size(); i++) {
            if (left == total - nums[i] - left) {
                return i;
            }
            left += nums[i];
        }
        return -1;
    }
};

// Largest # atleast twice of others
class Solution {
public:
    int dominantIndex(vector<int>& nums) {
        if (nums.size() == 1) {
            return 0;
        }
        int max1 = 0, max2 = 1;
        if (nums[max2] > nums[max1])
            swap(max1, max2);
        for (int i = 2; i < nums.size(); i++) {
            if (nums[i] > nums[max1]) {
                max2 = max1;
                max1 = i;
            } else if (nums[i] > nums[max2]) {
                max2 = i;
            }
        }
        if (nums[max2]*2 <= nums[max1]) {
            return max1;
        }
        return -1;
    }
};

// Plus one
class Solution {
public:
    vector<int> plusOne(vector<int>& digits) {
        int c = 1, i = digits.size()-1;
        do {
            int val = digits[i] + c;
            c = (val >= 10) ? 1 : 0;
            digits[i--] = val % 10;
        } while (c == 1 && i >= 0);
        if (c == 1) {
            digits.insert(digits.begin(), 1);
        }
        return digits;
    }
};

// Height checker
class Solution {
public:
    int heightChecker(vector<int>& heights) {
        vector<int> v = heights;
        sort(v.begin(), v.end());
        int cnt = 0;
        for (auto itr = v.begin(), hItr = heights.begin(); itr != v.end(), hItr != heights.end(); hItr++, itr++) {
            if (*itr != *hItr) {
                cnt++;
            }
        }
        return cnt;
    }
};

//Third max number in an array with dups
class Solution {
public:
    int thirdMax(vector<int>& nums) {
        unordered_set<int> s(nums.begin(), nums.end());
        nums.assign(s.begin(), s.end());
        if (nums.empty()) {
            return -1;
        } else if (nums.size() == 1) {
            return nums[0];
        } else if (nums.size() == 2) {
            return ((nums[0] == nums[1]) ? nums[0] : max(nums[0], nums[1]));
        }
        //return nums[nums.size()-3]; if using a set instead of unordered_set
        int max1 = nums[0], max2 = nums[1], max3 = nums[2];
        if (max2 > max1)
            swap(max1, max2);
        if (max3 > max1)
            swap(max1, max3);
        if (max3 > max2)
            swap(max2, max3);
        for (int i = 3; i < nums.size(); i++) {
            int num = nums[i];
            if (num > max1) {
                max3 = max2;
                max2 = max1;
                max1 = num;
            } else if (num > max2) {
                max3 = max2;
                max2 = num;
            } else if (num > max3) {
                max3 = num;
            }
        }
        return max3;
    }
};

// Find all nos disappeared in an array [1...n]
class Solution {
public:
    vector<int> findDisappearedNumbers(vector<int>& nums) {
        bitset<100000> b;
        for (int num : nums) {
            b.set(num-1);
        }
        vector<int> ret;
        for (int i = 0; i < nums.size(); i++) {
            if (!b.test(i)) {
                ret.push_back(i+1);
            }
        }
        return ret;
    }
};

//squares of sorted array with negative numbers
#include <algorithm>
class Solution {
public:
    vector<int> sortedSquares(vector<int>& nums) {
        vector<int> neg;
        for (auto itr = nums.begin(); itr != nums.end(); ) {
            int num = *itr;
            if (num < 0) {
                neg.insert(neg.begin(), num*num);
                nums.erase(itr);
            } else {
                *itr = num*num; ++itr;
            }
        }
        if (!neg.empty()) {
            vector<int> dst;
            std::merge(nums.begin(), nums.end(), neg.begin(), neg.end(), std::back_inserter(dst));
            return dst;
        }
        return nums;
    }
};

//Remove element
class Solution {
public:
    int removeElement(vector<int>& nums, int val) {
        int w = 0;
        for (int r = 0; r < nums.size(); r++) {
            if (nums[r] != val) {
                nums[w++] = nums[r];
            }
        }
        return w;
    }
};

//Remove dups from sorted array
class Solution {
public:
    int removeDuplicates(vector<int>& nums) {
        if (nums.empty() || nums.size() == 1) {
            return nums.size();
        }
        int w = 1; int val = nums[0];
        for (int r = 1; r < nums.size(); r++) {
            if (nums[r] != val) {
                nums[w++] = val = nums[r];
            }
        }
        return w;
    }
};

//sort array by parity
class Solution {
public:
    vector<int> sortArrayByParity(vector<int>& A) {
        int odd = -1;
        for (int r = 0; r < A.size(); ++r) {
            if (A[r] %2 != 0) {
                odd = (odd == -1) ? r : odd;
            } else {
                if (odd != -1) {
                    A.insert(A.begin()+odd, A[r]); odd++;
                    if (r+1 < A.size()) {
                        A.erase(A.begin()+r+1);
                    }                    
                }
            }
        }
        return A;
    }
};

//Move zeroes
class Solution {
public:
    void moveZeroes(vector<int>& nums) {
        int w = 0;
        for (int r = 0; r < nums.size(); r++) {
            if (nums[r] != 0) {
                nums[w++] = nums[r];
            }
        }
        for ( ; w < nums.size(); w++) {
            nums[w] = 0;
        }
    }
};

//Replace elements with the largest number to its right
class Solution {
public:
    vector<int> replaceElements(vector<int>& arr) {
        if (arr.empty()) {
            return arr;
        }
        int len = arr.size(), max = arr[len-1];
        arr[len-1] = -1;
        for (int i = len-2; i >=0; i--) {
            int val = arr[i];
            arr[i] = max;
            max = (val > max) ? val : max;
        }
        return arr;
    }
};

//valid mountain array
class Solution {
public:
    bool validMountainArray(vector<int>& arr) {
        bool up = false, down = false;
        if (arr.size() < 3) {
            return false;
        }
        for (int i = 1; i < arr.size(); i++) {
            if (arr[i-1] == arr[i]) {
                return false;
            } else if (arr[i-1] < arr[i]) { // strict increase
                if (down == true) {
                    return false;
                }
                up = true;
            } else if (arr[i-1] > arr[i]) { // strict decrease
                if (up != true) {
                    return false;
                }
                down = true;
            }
        }
        return (up && down);
    }
};

//Check if N and its double exists
class Solution {
public:
    bool checkIfExist(vector<int>& arr) {
        set<int> s;
        for (int num : arr) {
            if (s.find(num*2) != s.end() ||
                (num % 2 == 0 && s.find(num/2) != s.end())) {
                return true;
            }
            s.insert(num);
        }
        return false;
    }
};

//Merge sorted array
class Solution {
public:
    void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {
        nums1.resize(m);
        int i = m, j = n; 
        auto itr1 = nums1.begin(), itr2 = nums2.begin();
        for (; itr1 != nums1.end() && itr2 != nums2.end() && i > 0 && j > 0; ) {
            if (*itr1 <= *itr2) {
                ++itr1; --i;
            } else {
                nums1.insert(itr1, *itr2); ++itr1; // move itr1 past the new element.
                ++itr2; --j;
            }
        }
        for (; itr2 != nums2.end() && j > 0; ++itr2) {
            nums1.push_back(*itr2); j--;
        }
    }
};

//Duplicate if zero present
class Solution {
public:
    void duplicateZeros(vector<int>& arr) {
        int dups = 0, len = arr.size()-1;
        for (int i = 0; i <= len-dups; i++) {
            if (arr[i] == 0) {
                if (i == len-dups) {
                    arr[len--] = 0;
                    break;
                }
                ++dups;
            }
        }
        int last = len-dups;
        for (int i = last; i >= 0; i--) {
             if (arr[i] == 0) {
                 arr[i+dups] = 0;
                 dups--;
                 arr[i+dups] = 0;
             } else {
                 arr[i+dups] = arr[i];
             }
        }
    }
};

//Max consecutive ones
class Solution {
public:
    int findMaxConsecutiveOnes(vector<int>& nums) {
        int max = 0, count = 0;
        for (int num : nums) {
            if (num == 1) {
                count++;
            } else {
                max = (count > max) ? count : max;
                count = 0;
            }
        }
       return (count > max) ? count : max;
    }
};

//Find no with even no. of digits
#include <math.h>

class Solution {
public:
    int findNumbers(vector<int>& nums) {
        int cnt = 0;
        for (int num : nums) {
            for (int powIndex = 1; powIndex <= 5; ++powIndex) {
                int mod = int(pow(10, powIndex));
                if (num == mod || num % mod == num) {
                    int digits = num == mod ? powIndex+1 : powIndex;
                    if (digits % 2 == 0) {
                        ++cnt;
                    }
                    break;
                }
            }
        }
        return cnt;
    }
};
